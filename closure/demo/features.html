<!doctype html>
<html>
<head>
  <script type="text/javascript">var _sf_startpt=(new Date()).getTime()</script>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>CoffeeScript/Google Closure Features</title>
  <link rel="STYLESHEET" href="http://bolinfest.com/javascript/closure.css">
  <link rel="STYLESHEET" href="http://bolinfest.com/javascript/prettify/src/prettify.css">
  <style>
h1 {
  font-size: 18px;
  margin-bottom: 0;
}

.tagline {
  margin-bottom: 1em;
  font-style: italic;
}

h2 {
  font-size: 16px;
}

h3 {
  font-size: 14px;
}

code {
  color: green;
}

dd {
  margin-bottom: 1em;
}
  </style>
</head>
<body onload="prettyPrint()">

<div id="info-column">
  <div id="abstract"></div>
  <div id="toc"></div>
  <div id="promo"></div>
</div>
<div id="content">
  <script src="http://bolinfest.com/javascript/toc.js"></script>
  <script type="text/javascript">
LINKS = [
  '#backstory',
  'How We Got Here',

  '#features',
  'Features of Closure Mode',

  '#future_work',
  'Future Work'
];

ABSTRACT = 'Introduces an optional <b>Closure Mode</b> for CoffeeScript ' +
    'that generates JavaScript that interoperates more naturally with the ' +
    '<a href="http://code.google.com/closure/library/">Closure Library</a> ' +
    'and can be processed more effectively by the ' +
    '<a href="http://code.google.com/closure/compiler/">Closure Compiler</a>.';

PROMO_TEXT = 'Learn how to leverage all of the Closure Tools in ' +
    '<em><a href="' + BOOK_URL + '" target="_blank">' +
    'Closure: The Definitive Guide' + '</a></em><p>';
</script>

<div class="article">

<h1>Closure Mode for CoffeeScript</h1>
<div class="tagline">Unfancy Closure Library JavaScript</div>

The JavaScript generated by
<a href="http://jashkenas.github.com/coffee-script/">CoffeeScript</a> works
perfectly fine, but it is not written in a way that can reap the full benefits
of the <a href="http://code.google.com/closure/compiler/">Closure Compiler</a>.

The <a href="index.html">demo</a> illustrates how an optional
<b>Closure Mode</b> yields JavaScript that can be compiled effectively
using the <a href="http://code.google.com/closure/compiler/docs/api-tutorial3.html">
Advanced mode</a> of the Closure Compiler. Supporting Closure Mode requires some
small amendments to the CoffeeScript grammar, as discussed in the section on
<a href="#expressing_dependencies">expressing dependencies</a>.

<h2 id="backstory">How We Got Here</h2>

The <a href="http://code.google.com/closure/">Closure Tools</a> were created to
make it easier to maintain large JavaScript codebases, leveraging organizational
constructs such as type-checking and namespaces. However, in creating the
Closure Library, it was decided that it must always be possible to run
Library code as ordinary JavaScript, i.e., without any sort of processing step.
Therefore, it was not permissible for the Library to be written in any sort of
superset/alternate form of JavaScript that was not recognized natively by browsers.
The only viable option was to include any metadata needed by the Closure Tools
inside JavaScript comments. This made it possible to build a rich set of tools,
though it resulted in verbose source code due to all of the annotations.
<p>
Previously, most other attempts to address the JavaScript tooling issue were to
use an existing programming language (that already had mature tools) and then
create a tool that translated that existing language into JavaScript. This was
the approach taken by the <a href="http://code.google.com/webtoolkit/">Google
Web Toolkit (GWT)</a> and <a href="http://code.google.com/p/ocamljs/">ocamljs</a>,
among others.
The common problem with that approach is that there is inevitably an "impedence
mistmatch" between JavaScript and the language being translated into JavaScript.
For example, Java supports <code>int</code>s and <code>float</code>s whereas
JavaScript only has <code>number</code>. Further, JavaScript has first-order
functions that are not available in Java, so it is not possible to use the full
language when limiting oneself to GWT.
<p>
Recently, more developers have come to embrace JavaScript and there is more
interest in the advancement of the language. As such, creating new languages
(such as CoffeeScript) that are designed from the outset to be translated into
JavaScript eliminates the "impedence mismatch" problem from before while making
it possible to experiment with new language features. Google's
<a href="http://code.google.com/p/traceur-compiler/">Traceur</a> project is
specifically designed to make it possible to experiment with future features
of JavaScript in the browser today.
<p>
Therefore, rather than awkwardly adding metadata in the form of comments in
source code, a more elegant solution is to use a programming language with a
grammar that makes it possible to express that metadata directly. For example,
in Closure Library code, a constructor function is annotated with
<code>@constructor</code> in a JSDoc comment, whereas in CoffeeScript, there is
explicit support for classes via a <code>class</code> construct. This stronger
grammar makes it easier to generate the JavaScript with annotations for the
Closure Compiler, which is precisely the goal of Closure Mode for CoffeeScript. 
 

<h2 id="features">Features of Closure Mode</h2>

This section enumerates the changes in JavaScript code generation when Closure
Mode is used to generate JavaScript from CoffeeScript.

<h3>Creating a Class</h3>

<dl>

<dt>A <code>goog.provide()</code> statement is automatically inserted for the
class.</dt>
<dd>
Normally, when writing Closure Library code by hand, the name of a
class appears at least twice: once in a <code>goog.provide()</code> statement
and again in the constructor function declaration.
This results in repeated information that may get out of sync.
Because a class is an official
construct in CoffeeScript, the name of the class appears in only one place, so
there is no possibility of inconsistency in the generated JavaScript.
</dd>

<dt>JSDoc with a <code>@constructor</code> annotation
is automatically inserted before the constructor function.</dt>
<dd>
This ensures that
if type-checking is enabled in the Closure Compiler, it will be able to
recognize a constructor/class properly.
</dd>

<h3>Creating a Subclass</h3>

<dl>
<dt>JSDoc with an <code>@extends</code> annotation
is automatically inserted before the constructor function.
</dt>
<dd>
This ensures that
if type-checking is enabled in the Closure Compiler, it will be able to
recognize a subclass relationship properly.
</dd>

<dt>The <code>goog.inherits()</code> call required for subclassing is
automatically inserted after the constructor function.</dt>
<dd>
Normally,
CoffeeScript needs to insert two functions into the generated JavaScript in
order to establish the subclass relationship:
<code>__extends()</code> and <code>__hasProp()</code>. After inserting these
functions and declaring the constructor function, <code>__extends()</code> is
called where <code>goog.inherits()</code> is normally called in Closure Library
code. Therefore, instead of declaring any new functions, Closure Mode simply
calls <code>goog.inherits()</code>. 
</dd>

<dt>
<code>super</code> calls in CoffeeScript are rewritten in a Library-appropriate
way.
</dt>
<dd>
The <code>__extends</code> function in CoffeeScript introduces a property named
<code>__super__</code> whereas the <code>goog.inherits</code> function in the
Closure Library introduces a functionally equivalent property named
<code>superClass_</code>. Both of these properties are used in calling
superclass constructors and methods, so they need to be updated in Closure Mode,
accordingly.
</dd>

</dl>

<h3 id="expressing_dependencies">Expressing Dependencies</h3>

<dl>
<dt>An <code>include</code> construct is introduced into the CoffeeScript
grammar that produces <code>goog.require()</code> statements.
</dt>
<dd>
In Closure Mode, the following line of CoffeeScript:
<pre class="prettyprint">
include goog.dom
</pre>
becomes the following JavaScript:
<pre class="prettyprint">
goog.require('goog.dom');
</pre>
It is more analogous to the <code>import</code> statement in Python.
(<code>include</code> was chosen instead of <code>import</code> because
<code>import</code> is a reserved word in JavaScript, so it already has some
special handling in CoffeeScript.)
</dd>

<dl>
<dt>An <code>include...as</code> construct is introduced into the CoffeeScript
grammar that produces <code>goog.require()</code> statements.
</dt>
<dd>
In Closure Mode, an <code>include</code> statement has an optional
<code>as</code> clause that makes it possible to refer to the imported namespace
via a shorthand. This is implemented such that it leverages
<a href="https://docs.google.com/document/pub?id=1ETFAuh2kaXMVL-vafUYhaWlhl6b5D9TOvboVg7Zl68Y">goog.scope()</a>,
which is processed in a special way by the Closure Compiler in
<a href="http://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/javascript/jscomp/ScopedAliases.java">ScopedAliases.java</a>.
For example, the following line of CoffeeScript:
<pre class="prettyprint">
include goog.array as arr
</pre>
Becomes the following Closure Library code:
<pre class="prettyprint">
goog.require('goog.array');

goog.scope(function() {
  var arr = goog.array;
;

}); // close goog.scope()
</pre>
Therefore, throughout the rest of the file, wherever <code>goog.array</code>
would be used, <code>arr</code> can be used as an alias instead.
</dd>

<dt><code>goog.provide()</code> and <code>goog.require()</code> statements are
automatically sorted alphabetically in the generated JavaScript code.
</dt>
<dd>
This is not necessarily a big win, but it seemed like a nice touch!
</dd>
</dl>

<h2 id="future_work">Future Work</h2>

Although Closure Mode makes it possible to write Closure-Compiler-friendly
JavaScript, it does not yet support all of the annotations in the Closure
Library. This section lists the high-priority features that need to be added.

<h3>Type Information</h3> 

For many, of the most compelling features of the Closure Compiler is its
type-checker. Type-checking is only effective when the JavaScript being compiled
is annotated with type information.
There already appears to be some
<a href="https://github.com/jstrachan/coffee-script/blob/master/TypeAnnotations.md">
interesting work being done in this area</a>, so perhaps the efforts of
UberScript and Closure Mode can be combined.

<h3>Enums</h3>

In Closure, an enum is simply an object literal whose values are treated as
though they were enum values. Because these values are frequently inlined by
the Compiler and the enum definition is removed during compilation, it is
illegal to iterate over an enums values using the <code>for..in</code> operator
in JavaScript when code is compiled in Advanced mode. One alternative is to
add a method to the enum that returns an array of the values:

<pre class="prettyprint">
/** @enum {string} */
TrafficLight = {
  RED: '#ff0000',
  YELLOW: '#ffff00',
  GREEN: '#00ff00'
};
TrafficLight.values = function() {
  return [TrafficLight.RED, TrafficLight.GREEN, TrafficLight.BLUE];
};
</pre>

Unfortunately, this method is tedious to maintain by hand because it must be
kept in sync with the actual enum values. If <code>enum</code> were a recognized
construct like <code>class</code> in CoffeeScript, then both the declaration and
the <code>values()</code> method could be generated so they were guaranteed to
be in sync.

<h3>Utilities</h3>

Currently, Closure Mode focuses on converting classes effectively, but some
Closure Library files are just collections of related utility functions
(<code>goog.array</code>, <code>goog.string</code>, etc.). It should also be
possible to create these types of libraries efficiently in CoffeeScript.

<h3>Leveraging More Closure Library Built-ins</h3>

By default, array iterators in CoffeeScript are translated into
verbose <code>for</code> loops (though they are admittedly more efficient in
terms of function calls):

<pre class="prettyprint">
# CoffeeScript
alert note for note in ['do', 're', 'mi']
roots = (Math.sqrt num for num in [1, 4, 9])
</pre>

<pre class="prettyprint">
// Generated JavaScript
var note, num, roots, _i, _len, _ref;
_ref = ['do', 're', 'mi'];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  note = _ref[_i];
  alert(note);
}
roots = (function() {
  var _j, _len2, _ref2, _results;
  _ref2 = [1, 4, 9];
  _results = [];
  for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
    num = _ref2[_j];
    _results.push(Math.sqrt(num));
  }
  return _results;
})();
</pre>

In Closure Mode, the generated JavaScript would be more familiar to a Closure
developer if it leveraged the existing <code>goog.array.forEach()</code> and
<code>goog.array.map()</code> functions in the Closure Library:

<pre class="prettyprint">
goog.array.forEach(['do', 're', 'mi'], function(note) { alert(note); });
var roots = goog.array.map([1, 4, 9],
    function(num) { return Math.sqrt(num); });
</pre>

<h3>plovr</h3>

<a href="http://plovr.com/">plovr</a> is a Closure build tool. One of its many
features is that it makes the conversion of Closure Templates to JavaScript
seamless. If there is sufficient interest, similar functionality will be added
for CoffeeScript, using Rhino to run the CoffeeScript compiler.

</div> <!--  close .article -->
</div> <!--  close #content -->

<script src="http://bolinfest.com/javascript/prettify/src/prettify.js"></script>
<script type="text/javascript">
var _sf_async_config={uid:22053,domain:"bolinfest.com"};
(function(){
  function loadChartbeat() {
    window._sf_endpt=(new Date()).getTime();
    var e = document.createElement('script');
    e.setAttribute('language', 'javascript');
    e.setAttribute('type', 'text/javascript');
    e.setAttribute('src',
       (("https:" == document.location.protocol) ? "https://a248.e.akamai.net/chartbeat.download.akamai.com/102508/" : "http://static.chartbeat.com/") +
       "js/chartbeat.js");
    document.body.appendChild(e);
  }
  var oldonload = window.onload;
  window.onload = (typeof window.onload != 'function') ?
     loadChartbeat : function() { oldonload(); loadChartbeat(); };
})();

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-1213368-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

</body>
</html>
